// Auto-generated by drizzle-kit introspect - do not edit manually
import { pgTable, uniqueIndex, index, foreignKey, uuid, varchar, timestamp, unique, text, serial, jsonb, integer, bigint, date, numeric, boolean } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"



export const ownerNameAliases = pgTable("owner_name_aliases", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	aliasName: varchar("alias_name", { length: 255 }).notNull(),
	canonicalName: varchar("canonical_name", { length: 255 }).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	userId: uuid("user_id").notNull(),
}, (table) => [
	uniqueIndex("owner_name_aliases_alias_lower_per_user_unique").using("btree", sql`user_id`, sql`lower((alias_name)::text)`),
	index().using("btree", table.canonicalName.asc().nullsLast().op("text_ops")),
	index().using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "owner_name_aliases_user_id_fkey"
		}).onDelete("cascade"),
]);

export const users = pgTable("users", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	firebaseUid: varchar("firebase_uid", { length: 128 }).notNull(),
	email: varchar({ length: 255 }).notNull(),
	displayName: varchar("display_name", { length: 255 }),
	photoUrl: text("photo_url"),
	provider: varchar({ length: 50 }).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	lastLoginAt: timestamp("last_login_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index().using("btree", table.email.asc().nullsLast().op("text_ops")),
	index().using("btree", table.firebaseUid.asc().nullsLast().op("text_ops")),
	unique("users_firebase_uid_key").on(table.firebaseUid),
]);

export const pgmigrations = pgTable("pgmigrations", {
	id: serial().primaryKey().notNull(),
	name: varchar({ length: 255 }).notNull(),
	runOn: timestamp("run_on", { mode: 'string' }).notNull(),
});

export const llmCache = pgTable("llm_cache", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	cacheKey: varchar("cache_key", { length: 64 }).notNull(),
	operationType: varchar("operation_type", { length: 50 }).notNull(),
	provider: varchar({ length: 50 }).notNull(),
	responseData: jsonb("response_data").notNull(),
	promptTokens: integer("prompt_tokens").default(0).notNull(),
	completionTokens: integer("completion_tokens").default(0).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index().using("btree", table.cacheKey.asc().nullsLast().op("text_ops")),
	index().using("btree", table.createdAt.asc().nullsLast().op("timestamptz_ops")),
	unique("llm_cache_cache_key_key").on(table.cacheKey),
]);

export const documents = pgTable("documents", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	filename: varchar({ length: 255 }).notNull(),
	originalFilename: varchar("original_filename", { length: 255 }).notNull(),
	mimeType: varchar("mime_type", { length: 100 }).notNull(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	sizeBytes: bigint("size_bytes", { mode: "number" }).notNull(),
	storagePath: text("storage_path").notNull(),
	metadata: jsonb().default({}),
	expiryDate: date("expiry_date"),
	documentType: varchar("document_type", { length: 100 }),
	documentOwner: varchar("document_owner", { length: 255 }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	category: varchar({ length: 50 }),
	issueDate: date("issue_date"),
	country: varchar({ length: 2 }),
	amountValue: numeric("amount_value", { precision: 15, scale:  2 }),
	amountCurrency: varchar("amount_currency", { length: 3 }),
	thumbnail: text(),
	userId: uuid("user_id").notNull(),
}, (table) => [
	index().using("btree", table.category.asc().nullsLast().op("text_ops")),
	index().using("btree", table.country.asc().nullsLast().op("text_ops")),
	index().using("btree", table.createdAt.asc().nullsLast().op("timestamptz_ops")),
	index().using("btree", table.documentType.asc().nullsLast().op("text_ops")),
	index().using("btree", table.issueDate.asc().nullsLast().op("date_ops")),
	index("documents_metadata_gin").using("gin", table.metadata.asc().nullsLast().op("jsonb_ops")),
	index().using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "documents_user_id_fkey"
		}).onDelete("cascade"),
]);

export const providerConfigs = pgTable("provider_configs", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	name: varchar({ length: 100 }).notNull(),
	providerType: varchar("provider_type", { length: 50 }).notNull(),
	apiKey: text("api_key").notNull(),
	isActive: boolean("is_active").default(false).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	userId: uuid("user_id").notNull(),
}, (table) => [
	uniqueIndex("provider_configs_unique_active_per_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")).where(sql`(is_active = true)`),
	index().using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "provider_configs_user_id_fkey"
		}).onDelete("cascade"),
]);
