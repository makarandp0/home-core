// Auto-generated by drizzle-kit introspect - do not edit manually
import { pgTable, serial, varchar, timestamp, index, uuid, bigint, text, jsonb, date, unique, integer, boolean } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"



export const pgmigrations = pgTable("pgmigrations", {
	id: serial().primaryKey().notNull(),
	name: varchar({ length: 255 }).notNull(),
	runOn: timestamp("run_on", { mode: 'string' }).notNull(),
});

export const documents = pgTable("documents", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	filename: varchar({ length: 255 }).notNull(),
	originalFilename: varchar("original_filename", { length: 255 }).notNull(),
	mimeType: varchar("mime_type", { length: 100 }).notNull(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	sizeBytes: bigint("size_bytes", { mode: "number" }).notNull(),
	storagePath: text("storage_path").notNull(),
	metadata: jsonb().default({}),
	expiryDate: date("expiry_date"),
	documentType: varchar("document_type", { length: 100 }),
	documentOwner: varchar("document_owner", { length: 255 }),
	// New fields for enhanced document extraction
	category: varchar({ length: 50 }),
	issueDate: date("issue_date"),
	country: varchar({ length: 2 }),
	amountValue: varchar("amount_value", { length: 20 }), // stored as string to preserve precision
	amountCurrency: varchar("amount_currency", { length: 3 }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index().using("btree", table.createdAt.asc().nullsLast().op("timestamptz_ops")),
	index().using("btree", table.category.asc().nullsLast().op("text_ops")),
	index().using("btree", table.country.asc().nullsLast().op("text_ops")),
	index().using("btree", table.issueDate.asc().nullsLast().op("date_ops")),
	index().using("btree", table.documentType.asc().nullsLast().op("text_ops")),
]);

export const llmCache = pgTable("llm_cache", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	cacheKey: varchar("cache_key", { length: 64 }).notNull(),
	operationType: varchar("operation_type", { length: 50 }).notNull(),
	provider: varchar({ length: 50 }).notNull(),
	responseData: jsonb("response_data").notNull(),
	promptTokens: integer("prompt_tokens").default(0).notNull(),
	completionTokens: integer("completion_tokens").default(0).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index().using("btree", table.cacheKey.asc().nullsLast().op("text_ops")),
	index().using("btree", table.createdAt.asc().nullsLast().op("timestamptz_ops")),
	unique("llm_cache_cache_key_key").on(table.cacheKey),
]);

export const providerConfigs = pgTable("provider_configs", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	name: varchar({ length: 100 }).notNull(),
	providerType: varchar("provider_type", { length: 50 }).notNull(),
	apiKey: text("api_key").notNull(),
	isActive: boolean("is_active").default(false).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
});
